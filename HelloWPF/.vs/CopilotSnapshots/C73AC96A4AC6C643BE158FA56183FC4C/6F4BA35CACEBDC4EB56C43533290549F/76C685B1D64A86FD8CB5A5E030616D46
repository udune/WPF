using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;

namespace ch20_프로그레스바
{
    /// <summary>
    /// MainWindow.xaml에 대한 상호작용 논리
    /// ProgressBar 컨트롤의 진행 상태 표시 기능을 시연하는 메인 윈도우
    /// </summary>
    public partial class MainWindow : Window
    {
        /// <summary>
        /// MainWindow 생성자
        /// 윈도우가 생성될 때 호출되어 초기화 작업을 수행합니다.
        /// </summary>
        public MainWindow()
        {
            // XAML에 정의된 UI 요소들을 초기화합니다.
            InitializeComponent();
            
            /*
             * 이 예제는 기본적인 ProgressBar 사용법을 보여줍니다.
             * - 버튼 클릭으로 수동 진행률 업데이트
             * - 데이터 바인딩으로 퍼센트 표시
             * 
             * 실제 프로젝트에서는:
             * - 비동기 작업(파일 다운로드, 데이터 처리 등)과 함께 사용
             * - Task, async/await와 IProgress<T> 활용
             * - DispatcherTimer로 자동 업데이트
             */
        }

        /// <summary>
        /// 버튼 클릭 이벤트 핸들러
        /// ProgressBar의 Value를 10씩 증가시킵니다.
        /// </summary>
        /// <param name="sender">이벤트를 발생시킨 객체 (Button)</param>
        /// <param name="e">이벤트 데이터</param>
        private void Button_Click(object sender, RoutedEventArgs e)
        {
            pb.Value += 10;
            // ProgressBar의 Value를 10씩 증가
            // 0 → 10 → 20 → 30 → ... → 100
            // Maximum이 100이므로 100 이상은 증가하지 않음
            
            /*
             * 동작 설명:
             * 
             * 1. pb는 XAML에서 정의한 ProgressBar의 Name
             * 2. Value는 현재 진행값 (0~100)
             * 3. += 10으로 10씩 증가
             * 4. 데이터 바인딩으로 TextBlock의 텍스트도 자동 업데이트
             * 
             * 예시:
             * 초기: pb.Value = 0  → "0%"
             * 1번 클릭: pb.Value = 10 → "10%"
             * 2번 클릭: pb.Value = 20 → "20%"
             * 10번 클릭: pb.Value = 100 → "100%"
             * 11번 클릭: pb.Value = 100 (Maximum 초과 안 됨)
             * 
             * 개선 사항:
             * - Maximum 도달 시 버튼 비활성화
             * - 완료 메시지 표시
             * - 진행률 초기화 버튼 추가
             */
        }
        
        /*
         * ProgressBar 코드 비하인드 활용 예제:
         * 
         * 1. 수동으로 진행률 설정:
         * 
         *    private void SetProgress_Click(object sender, RoutedEventArgs e)
         *    {
         *        pb.Value = 50; // 50%로 설정
         *    }
         *    
         *    private void IncrementProgress_Click(object sender, RoutedEventArgs e)
         *    {
         *        if (pb.Value < pb.Maximum)
         *        {
         *            pb.Value += 10;
         *        }
         *        else
         *        {
         *            MessageBox.Show("작업 완료!");
         *        }
         *    }
         *    
         *    private void ResetProgress_Click(object sender, RoutedEventArgs e)
         *    {
         *        pb.Value = 0; // 초기화
         *    }
         * 
         * 2. DispatcherTimer로 자동 진행:
         * 
         *    private System.Windows.Threading.DispatcherTimer timer;
         *    
         *    private void StartAutoProgress_Click(object sender, RoutedEventArgs e)
         *    {
         *        pb.Value = 0;
         *        
         *        timer = new System.Windows.Threading.DispatcherTimer();
         *        timer.Interval = TimeSpan.FromMilliseconds(100);
         *        timer.Tick += Timer_Tick;
         *        timer.Start();
         *    }
         *    
         *    private void Timer_Tick(object? sender, EventArgs e)
         *    {
         *        if (pb.Value < pb.Maximum)
         *        {
         *            pb.Value += 1;
         *        }
         *        else
         *        {
         *            timer?.Stop();
         *            MessageBox.Show("완료!");
         *        }
         *    }
         * 
         * 3. 비동기 작업과 함께 사용 (파일 다운로드 시뮬레이션):
         * 
         *    private async void DownloadFile_Click(object sender, RoutedEventArgs e)
         *    {
         *        pb.Value = 0;
         *        pb.Maximum = 100;
         *        
         *        // Progress 객체 생성
         *        var progress = new Progress<int>(value =>
         *        {
         *            pb.Value = value;
         *            statusText.Text = $"다운로드 중... {value}%";
         *        });
         *        
         *        await SimulateDownloadAsync(progress);
         *        
         *        MessageBox.Show("다운로드 완료!");
         *    }
         *    
         *    private async Task SimulateDownloadAsync(IProgress<int> progress)
         *    {
         *        for (int i = 0; i <= 100; i++)
         *        {
         *            await Task.Delay(50); // 다운로드 시뮬레이션
         *            progress.Report(i);
         *        }
         *    }
         * 
         * 4. 실제 파일 다운로드 예제:
         * 
         *    private async void DownloadRealFile_Click(object sender, RoutedEventArgs e)
         *    {
         *        using (var client = new HttpClient())
         *        {
         *            string url = "https://example.com/largefile.zip";
         *            
         *            // 진행률 보고 설정
         *            var progress = new Progress<double>(value =>
         *            {
         *                pb.Value = value;
         *                statusText.Text = $"다운로드 중... {value:F1}%";
         *            });
         *            
         *            try
         *            {
         *                await DownloadFileWithProgressAsync(client, url, "output.zip", progress);
         *                MessageBox.Show("다운로드 완료!");
         *            }
         *            catch (Exception ex)
         *            {
         *                MessageBox.Show($"오류: {ex.Message}");
         *            }
         *        }
         *    }
         *    
         *    private async Task DownloadFileWithProgressAsync(
         *        HttpClient client, 
         *        string url, 
         *        string outputPath, 
         *        IProgress<double> progress)
         *    {
         *        using (var response = await client.GetAsync(url, HttpCompletionOption.ResponseHeadersRead))
         *        {
         *            response.EnsureSuccessStatusCode();
         *            
         *            var totalBytes = response.Content.Headers.ContentLength ?? -1L;
         *            var canReportProgress = totalBytes != -1;
         *            
         *            using (var contentStream = await response.Content.ReadAsStreamAsync())
         *            using (var fileStream = new FileStream(outputPath, FileMode.Create, FileAccess.Write, FileShare.None))
         *            {
         *                var buffer = new byte[8192];
         *                var totalRead = 0L;
         *                int bytesRead;
         *                
         *                while ((bytesRead = await contentStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
         *                {
         *                    await fileStream.WriteAsync(buffer, 0, bytesRead);
         *                    totalRead += bytesRead;
         *                    
         *                    if (canReportProgress)
         *                    {
         *                        var progressPercentage = (double)totalRead / totalBytes * 100;
         *                        progress.Report(progressPercentage);
         *                    }
         *                }
         *            }
         *        }
         *    }
         * 
         * 5. Indeterminate 모드 토글:
         * 
         *    private void ToggleIndeterminate_Click(object sender, RoutedEventArgs e)
         *    {
         *        pb.IsIndeterminate = !pb.IsIndeterminate;
         *        
         *        if (pb.IsIndeterminate)
         *        {
         *            statusText.Text = "처리 중...";
         *        }
         *        else
         *        {
         *            statusText.Text = $"{pb.Value}%";
         *        }
         *    }
         * 
         * 6. 다중 단계 작업:
         * 
         *    private async void MultiStepTask_Click(object sender, RoutedEventArgs e)
         *    {
         *        pb.Value = 0;
         *        pb.Maximum = 100;
         *        
         *        // 단계 1: 데이터 로드 (33%)
         *        statusText.Text = "데이터 로딩 중...";
         *        await SimulateStepAsync(0, 33);
         *        
         *        // 단계 2: 데이터 처리 (33%)
         *        statusText.Text = "데이터 처리 중...";
         *        await SimulateStepAsync(33, 66);
         *        
         *        // 단계 3: 결과 저장 (34%)
         *        statusText.Text = "결과 저장 중...";
         *        await SimulateStepAsync(66, 100);
         *        
         *        statusText.Text = "완료!";
         *        MessageBox.Show("모든 작업 완료!");
         *    }
         *    
         *    private async Task SimulateStepAsync(int start, int end)
         *    {
         *        for (int i = start; i < end; i++)
         *        {
         *            await Task.Delay(30);
         *            pb.Value = i;
         *        }
         *    }
         * 
         * 7. 취소 가능한 작업:
         * 
         *    private CancellationTokenSource? cancellationTokenSource;
         *    
         *    private async void StartCancelableTask_Click(object sender, RoutedEventArgs e)
         *    {
         *        cancellationTokenSource = new CancellationTokenSource();
         *        pb.Value = 0;
         *        
         *        try
         *        {
         *            await LongRunningTaskAsync(cancellationTokenSource.Token);
         *            MessageBox.Show("작업 완료!");
         *        }
         *        catch (OperationCanceledException)
         *        {
         *            MessageBox.Show("작업이 취소되었습니다.");
         *        }
         *    }
         *    
         *    private void CancelTask_Click(object sender, RoutedEventArgs e)
         *    {
         *        cancellationTokenSource?.Cancel();
         *    }
         *    
         *    private async Task LongRunningTaskAsync(CancellationToken cancellationToken)
         *    {
         *        for (int i = 0; i <= 100; i++)
         *        {
         *            cancellationToken.ThrowIfCancellationRequested();
         *            
         *            await Task.Delay(50, cancellationToken);
         *            pb.Value = i;
         *        }
         *    }
         * 
         * 8. ValueChanged 이벤트 처리:
         * 
         *    private void ProgressBar_ValueChanged(object sender, RoutedPropertyChangedEventArgs<double> e)
         *    {
         *        // Value가 변경될 때마다 호출
         *        double oldValue = e.OldValue;
         *        double newValue = e.NewValue;
         *        
         *        statusText.Text = $"진행률: {newValue}%";
         *        
         *        // 완료 체크
         *        if (newValue >= pb.Maximum)
         *        {
         *            MessageBox.Show("작업 완료!");
         *        }
         *        
         *        // 색상 변경
         *        if (newValue < 30)
         *        {
         *            pb.Foreground = Brushes.Red;
         *        }
         *        else if (newValue < 70)
         *        {
         *            pb.Foreground = Brushes.Yellow;
         *        }
         *        else
         *        {
         *            pb.Foreground = Brushes.Green;
         *        }
         *    }
         * 
         * 9. 예상 남은 시간 계산:
         * 
         *    private DateTime startTime;
         *    
         *    private void StartWithTimeEstimate_Click(object sender, RoutedEventArgs e)
         *    {
         *        startTime = DateTime.Now;
         *        pb.Value = 0;
         *        
         *        var timer = new System.Windows.Threading.DispatcherTimer();
         *        timer.Interval = TimeSpan.FromMilliseconds(100);
         *        timer.Tick += (s, ev) =>
         *        {
         *            if (pb.Value < pb.Maximum)
         *            {
         *                pb.Value += 1;
         *                
         *                // 경과 시간
         *                var elapsed = DateTime.Now - startTime;
         *                
         *                // 예상 총 시간 = 경과 시간 / (진행률 / 100)
         *                if (pb.Value > 0)
         *                {
         *                    var estimatedTotal = TimeSpan.FromSeconds(elapsed.TotalSeconds * (100 / pb.Value));
         *                    var remaining = estimatedTotal - elapsed;
         *                    
         *                    timeText.Text = $"남은 시간: {remaining:mm\\:ss}";
         *                }
         *            }
         *            else
         *            {
         *                timer.Stop();
         *                timeText.Text = "완료!";
         *            }
         *        };
         *        timer.Start();
         *    }
         * 
         * 10. 병렬 작업 진행률:
         * 
         *     private async void ParallelTasks_Click(object sender, RoutedEventArgs e)
         *     {
         *         int totalTasks = 10;
         *         int completedTasks = 0;
         *         
         *         pb.Value = 0;
         *         pb.Maximum = totalTasks;
         *         
         *         var tasks = Enumerable.Range(0, totalTasks).Select(async i =>
         *         {
         *             await Task.Delay(Random.Shared.Next(1000, 3000));
         *             
         *             // UI 스레드에서 업데이트
         *             Dispatcher.Invoke(() =>
         *             {
         *                 completedTasks++;
         *                 pb.Value = completedTasks;
         *                 statusText.Text = $"{completedTasks}/{totalTasks} 작업 완료";
         *             });
         *         });
         *         
         *         await Task.WhenAll(tasks);
         *         MessageBox.Show("모든 작업 완료!");
         *     }
         * 
         * ProgressBar 코드 조작 관련 중요 사항:
         * 
         * 1. Value 설정:
         *    - pb.Value = 50;
         *    - Minimum ~ Maximum 범위 내에서만 유효
         * 
         * 2. Indeterminate 모드:
         *    - pb.IsIndeterminate = true;
         *    - Value 무시됨
         * 
         * 3. UI 스레드:
         *    - ProgressBar는 UI 컨트롤
         *    - 백그라운드 스레드에서 업데이트 시 Dispatcher 사용
         *    - Dispatcher.Invoke(() => pb.Value = x);
         * 
         * 4. IProgress<T>:
         *    - 비동기 작업에서 진행률 보고
         *    - 자동으로 UI 스레드로 마샬링
         * 
         * 5. 성능:
         *    - 너무 빈번한 업데이트 피하기
         *    - 최소 50-100ms 간격 권장
         * 
         * 6. 완료 처리:
         *    - Value >= Maximum 체크
         *    - ValueChanged 이벤트 활용
         * 
         * 7. 범위 검증:
         *    if (newValue >= pb.Minimum && newValue <= pb.Maximum)
         *    {
         *        pb.Value = newValue;
         *    }
         * 
         * 8. 바인딩:
         *    - Value를 ViewModel 속성에 바인딩
         *    - INotifyPropertyChanged 구현
         * 
         * 9. 애니메이션:
         *    - 부드러운 진행을 위해 애니메이션 사용
         *    - DoubleAnimation으로 Value 애니메이션
         * 
         * 10. 접근성:
         *     - AutomationProperties.Name 설정
         *     - 스크린 리더를 위한 설명 제공
         */
    }
}