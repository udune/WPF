MVVM 패턴 완전 가이드
=====================================================

ch34 MVVM 프로젝트 - WPF MVVM 패턴의 기본 구조

========== MVVM 패턴이란? ==========

MVVM (Model-View-ViewModel):
- WPF의 데이터 바인딩을 활용한 디자인 패턴
- Martin Fowler의 Presentation Model에서 파생
- Microsoft가 WPF/Silverlight용으로 개발
- View와 비즈니스 로직의 완전한 분리

구성 요소:
1. Model: 데이터와 비즈니스 로직
2. View: 사용자 인터페이스 (XAML)
3. ViewModel: View의 상태와 동작

데이터 흐름:
View ↔ DataBinding ↔ ViewModel ↔ Model


========== 프로젝트 구조 ==========

ch34 MVVM/
├── Models/
│   └── PersonModel.cs          (데이터 모델)
├── ViewModels/
│   └── PersonViewModel.cs      (뷰 로직)
├── Views/
│   ├── PersonView.xaml         (UI)
│   └── PersonView.xaml.cs      (코드 비하인드)
├── Commands/
│   └── PersonCommand.cs        (명령 구현)
├── MainWindow.xaml             (사용 안 됨)
├── MainWindow.xaml.cs
├── App.xaml                    (애플리케이션 진입점)
└── App.xaml.cs


========== 1. Model (PersonModel.cs) ==========

역할:
- 데이터 구조 정의
- 비즈니스 로직
- INotifyPropertyChanged 구현

핵심 코드:
```csharp
public class PersonModel : INotifyPropertyChanged
{
    public event PropertyChangedEventHandler? PropertyChanged;
    
    private string name;
    private int age;
    
    public string Name
    {
        get => name;
        set
        {
            name = value;
            OnPropertyChanged("Name");  // UI 업데이트 알림
        }
    }
    
    public int Age
    {
        get => age;
        set
        {
            age = value;
            OnPropertyChanged("Age");
        }
    }
    
    private void OnPropertyChanged(string name)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }
}
```

INotifyPropertyChanged:
- 속성 변경 시 UI에 알림
- WPF 양방향 바인딩의 핵심
- PropertyChanged 이벤트 발생

작동 원리:
1. Name 속성 변경
2. OnPropertyChanged("Name") 호출
3. PropertyChanged 이벤트 발생
4. WPF 바인딩 시스템이 감지
5. UI 자동 업데이트


========== 2. ViewModel (PersonViewModel.cs) ==========

역할:
- View의 상태와 동작 관리
- Model 데이터를 View에 제공
- Command를 통한 사용자 입력 처리
- View를 알지 못함 (참조 없음)

핵심 코드:
```csharp
public class PersonViewModel
{
    public PersonCommand PersonCommand { get; set; }
    public List<PersonModel> PersonList { get; set; }
    
    public PersonViewModel()
    {
        // 초기 데이터
        PersonList = new List<PersonModel>
        {
            new PersonModel {Name = "홍길동", Age = 100},
            new PersonModel {Name = "임꺽정", Age = 90},
            // ...
        };
        
        // Command 초기화
        PersonCommand = new PersonCommand(Message, CheckMessage);
    }
    
    private void Message(string? txt)
    {
        MessageBox.Show(txt);
    }
    
    private bool CheckMessage(string? txt)
    {
        return txt?.Length > 0;
    }
}
```

PersonList:
- View에서 표시할 데이터 컬렉션
- ListView.ItemsSource에 바인딩
- List<PersonModel> (정적) 또는
- ObservableCollection<PersonModel> (동적)

PersonCommand:
- 버튼 클릭 등의 사용자 동작 처리
- ICommand 인터페이스 구현
- Message: 실행할 동작
- CheckMessage: 실행 가능 여부 판단


========== 3. Command (PersonCommand.cs) ==========

역할:
- ICommand 인터페이스 구현
- View의 Command 속성에 바인딩
- 이벤트 핸들러의 대안
- 코드 비하인드 제거

핵심 코드:
```csharp
public class PersonCommand : ICommand
{
    public event EventHandler? CanExecuteChanged;
    
    Action<string?> execute;
    Predicate<string?> canExecute;
    
    public PersonCommand(Action<string?> msg, Predicate<string?> check)
    {
        execute = msg;
        canExecute = check;
    }
    
    public bool CanExecute(object? parameter)
    {
        return canExecute.Invoke(parameter as string);
    }
    
    public void Execute(object? parameter)
    {
        execute.Invoke(parameter as string);
    }
}
```

ICommand 인터페이스:
- CanExecuteChanged: 실행 가능 여부 변경 알림
- CanExecute: 실행 가능 여부 판단
- Execute: 실제 동작 수행

버튼 클릭 시 흐름:
1. WPF가 CanExecute(parameter) 호출
2. CheckMessage(parameter) 실행 → true/false
3. true이면 버튼 활성화, false이면 비활성화
4. 사용자가 버튼 클릭
5. WPF가 Execute(parameter) 호출
6. Message(parameter) 실행
7. MessageBox.Show(parameter)

버튼 상태 자동 관리:
- CommandParameter 변경 시
- CommandManager.RequerySuggested 발생
- CanExecute 재평가
- 버튼 활성화/비활성화 자동


========== 4. View (PersonView.xaml) ==========

역할:
- 사용자 인터페이스 정의
- DataContext로 ViewModel 연결
- 데이터 바인딩으로 표시 및 입력
- 코드 비하인드 최소화

핵심 코드:
```xaml
<Page x:Class="ch34_MVVM.Views.PersonView" ...>
    <Grid>
        <!-- ListView: 데이터 표시 -->
        <ListView x:Name="lv" ItemsSource="{Binding PersonList}">
            <ListView.View>
                <GridView>
                    <GridViewColumn Header="이름" 
                                   DisplayMemberBinding="{Binding Name}"/>
                    <GridViewColumn Header="나이" 
                                   DisplayMemberBinding="{Binding Age}"/>
                </GridView>
            </ListView.View>
        </ListView>
        
        <!-- 입력 및 버튼 -->
        <StackPanel>
            <!-- 선택된 항목의 Name 편집 -->
            <TextBox Text="{Binding ElementName=lv, 
                                   Path=SelectedItem.Name, 
                                   Mode=TwoWay, 
                                   UpdateSourceTrigger=PropertyChanged}"/>
            
            <!-- 선택된 항목의 Age 편집 -->
            <TextBox Text="{Binding ElementName=lv, 
                                   Path=SelectedItem.Age, 
                                   Mode=TwoWay, 
                                   UpdateSourceTrigger=PropertyChanged}"/>
            
            <!-- Command 바인딩 -->
            <Button Command="{Binding PersonCommand}"
                    CommandParameter="{Binding ElementName=tBox1, Path=Text}">
                버튼
            </Button>
        </StackPanel>
    </Grid>
</Page>
```

주요 바인딩:

1. ItemsSource 바인딩:
   ItemsSource="{Binding PersonList}"
   - PersonViewModel.PersonList에 바인딩
   - ListView에 데이터 표시

2. ElementName 바인딩:
   {Binding ElementName=lv, Path=SelectedItem.Name}
   - ListView의 SelectedItem.Name 참조
   - DataContext 대신 다른 요소 참조

3. Mode=TwoWay:
   - 양방향 바인딩
   - UI ↔ Model 동기화

4. UpdateSourceTrigger=PropertyChanged:
   - 타이핑할 때마다 즉시 업데이트

5. Command 바인딩:
   Command="{Binding PersonCommand}"
   - PersonViewModel.PersonCommand 바인딩
   - 버튼 클릭 시 Execute 호출


========== 5. View 코드 비하인드 (PersonView.xaml.cs) ==========

역할:
- DataContext 설정
- 최소한의 UI 로직만
- 비즈니스 로직 금지

핵심 코드:
```csharp
public partial class PersonView : Page
{
    public PersonView()
    {
        InitializeComponent();
        DataContext = new PersonViewModel();
    }
}
```

DataContext:
- View와 ViewModel 연결의 핵심
- 모든 바인딩의 기본 소스
- 자식 요소로 상속

바인딩 해석:
{Binding PersonList}
1. 현재 요소의 DataContext 확인
2. PersonViewModel 발견
3. PersonViewModel.PersonList 접근
4. ListView.ItemsSource에 할당


========== 데이터 흐름 전체 ==========

1. 초기화:
   PersonView 생성
   ↓
   InitializeComponent() (XAML 로드)
   ↓
   DataContext = new PersonViewModel()
   ↓
   PersonViewModel 생성자 실행
   ↓
   PersonList 초기화, PersonCommand 생성
   ↓
   바인딩 평가 시작
   ↓
   ListView에 데이터 표시

2. 사용자 인터랙션:
   ListView 항목 선택
   ↓
   SelectedItem = PersonModel
   ↓
   TextBox에 Name, Age 표시
   ↓
   TextBox에서 텍스트 수정
   ↓
   UpdateSourceTrigger=PropertyChanged
   ↓
   즉시 PersonModel.Name 업데이트
   ↓
   OnPropertyChanged 호출
   ↓
   PropertyChanged 이벤트 발생
   ↓
   ListView 자동 업데이트

3. Command 실행:
   텍스트 입력
   ↓
   CommandManager.RequerySuggested
   ↓
   CanExecute(text) 호출
   ↓
   CheckMessage(text) → true
   ↓
   버튼 활성화
   ↓
   사용자가 버튼 클릭
   ↓
   Execute(text) 호출
   ↓
   Message(text) 실행
   ↓
   MessageBox.Show(text)


========== MVVM의 장점 ==========

1. 관심사의 분리:
   - View: UI만
   - ViewModel: 로직만
   - Model: 데이터만

2. 테스트 용이:
   - ViewModel 단위 테스트
   - UI 없이 테스트 가능
   - Mock 객체 사용

3. 재사용성:
   - ViewModel 재사용
   - 여러 View에서 사용 가능

4. 협업:
   - 디자이너: XAML
   - 개발자: C#
   - 독립적 작업

5. 유지보수:
   - 로직이 한 곳에
   - 변경 영향 최소화


========== MVVM vs 다른 패턴 ==========

코드 비하인드 (전통적):
```xaml
<Button Click="Button_Click">버튼</Button>
```
```csharp
private void Button_Click(object sender, RoutedEventArgs e)
{
    MessageBox.Show(tBox1.Text);
}
```
문제: View와 로직 결합, 테스트 어려움

MVVM (Command):
```xaml
<Button Command="{Binding ClickCommand}">버튼</Button>
```
```csharp
public ICommand ClickCommand { get; }
ClickCommand = new RelayCommand(() => MessageBox.Show(Text));
```
장점: View와 로직 분리, 테스트 용이

MVC (Model-View-Controller):
- Controller가 View와 Model 중재
- WPF에서는 부자연스러움

MVP (Model-View-Presenter):
- Presenter가 View 제어
- View가 Presenter 참조
- MVVM보다 결합도 높음


========== 실전 MVVM 패턴 ==========

1. ObservableCollection 사용:
```csharp
public ObservableCollection<PersonModel> PersonList { get; set; }

PersonList.Add(new PersonModel { Name = "새사람", Age = 30 });
// ListView 자동 업데이트
```

2. RelayCommand 구현:
```csharp
public class RelayCommand : ICommand
{
    private readonly Action<object> _execute;
    private readonly Predicate<object> _canExecute;
    
    public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }
    
    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }
    
    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute(parameter);
    }
    
    public void Execute(object parameter)
    {
        _execute(parameter);
    }
}
```

3. 선택된 항목 관리:
```csharp
private PersonModel _selectedPerson;
public PersonModel SelectedPerson
{
    get => _selectedPerson;
    set
    {
        _selectedPerson = value;
        OnPropertyChanged();
        DeleteCommand.RaiseCanExecuteChanged();
    }
}
```

4. CRUD 작업:
```csharp
public ICommand AddCommand { get; }
public ICommand EditCommand { get; }
public ICommand DeleteCommand { get; }

AddCommand = new RelayCommand(
    _ => PersonList.Add(new PersonModel()),
    _ => true
);

DeleteCommand = new RelayCommand(
    _ => PersonList.Remove(SelectedPerson),
    _ => SelectedPerson != null
);
```

5. 데이터 서비스 연동:
```csharp
private readonly IPersonService _personService;

public PersonViewModel(IPersonService personService)
{
    _personService = personService;
    LoadDataCommand = new AsyncRelayCommand(LoadDataAsync);
}

private async Task LoadDataAsync()
{
    var data = await _personService.GetAllAsync();
    PersonList = new ObservableCollection<PersonModel>(data);
}
```


========== MVVM 프레임워크 ==========

1. MVVM Light Toolkit:
   - 경량 프레임워크
   - RelayCommand, ViewModelBase
   - Messenger 패턴

2. Prism:
   - 엔터프라이즈급
   - Region 기반 네비게이션
   - 모듈화

3. CommunityToolkit.Mvvm:
   - Microsoft 공식
   - Source Generator
   - 간결한 코드

4. ReactiveUI:
   - 반응형 프로그래밍
   - Rx.NET 기반


========== 주의사항 ==========

1. ViewModel에서 View 참조 금지:
   - View에 대한 의존성 없음
   - IDialogService 등으로 추상화

2. 메모리 누수:
   - 이벤트 핸들러 해제
   - WeakEventManager 사용

3. 성능:
   - ObservableCollection 크기 제한
   - UpdateSourceTrigger 신중히 사용

4. 복잡도:
   - 간단한 앱에는 과할 수 있음
   - 프로젝트 규모에 맞게 적용

5. 학습 곡선:
   - 데이터 바인딩 이해 필요
   - Command 패턴 숙지


========== 요약 ==========

MVVM은 WPF의 강력한 데이터 바인딩을 활용한 패턴:

- Model: 데이터 + INotifyPropertyChanged
- ViewModel: 로직 + Command + 데이터 컬렉션
- View: XAML + 데이터 바인딩
- Command: ICommand 구현

데이터 흐름:
View ↔ Binding ↔ ViewModel ↔ Model

장점:
- 완전한 분리
- 테스트 용이
- 재사용성
- 유지보수성

이 예제는 MVVM의 기본 구조를 보여줍니다.
실전에서는 DI, 네비게이션, 서비스 등 추가 패턴을 사용합니다.
