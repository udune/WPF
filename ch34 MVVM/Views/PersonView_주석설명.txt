PersonView.xaml 상세 주석 설명
=====================================================

MVVM 패턴의 View 계층
사용자 인터페이스를 정의하며 ViewModel과 데이터 바인딩으로 연결됩니다.

========== Page 요소 ==========

<Page x:Class="ch34_MVVM.Views.PersonView" ...>

Page:
- Frame에서 호스팅되는 화면 단위
- Window 대신 사용 가능
- 내비게이션 지원

d:DesignHeight, d:DesignWidth:
- 디자인 타임 크기
- 실행 시에는 영향 없음

DataContext 설정 (PersonView.xaml.cs):
DataContext = new PersonViewModel();

모든 바인딩이 PersonViewModel 참조:
{Binding PersonList} = PersonViewModel.PersonList


========== ListView (데이터 표시) ==========

<ListView x:Name="lv" ItemsSource="{Binding PersonList}" Grid.Row="0">

x:Name="lv":
- XAML에서 참조할 이름
- ElementName 바인딩에 사용

ItemsSource="{Binding PersonList}":
- PersonViewModel.PersonList 바인딩
- List<PersonModel> 컬렉션

바인딩 흐름:
1. DataContext = PersonViewModel
2. {Binding PersonList} 평가
3. PersonViewModel.PersonList 가져오기
4. ListView에 데이터 표시


========== GridView (테이블 표시) ==========

<GridViewColumn Header="이름" DisplayMemberBinding="{Binding Name}" Width="150"/>

Header="이름":
- 열 제목 (헤더)

DisplayMemberBinding="{Binding Name}":
- PersonModel.Name 속성 표시
- 각 행의 데이터

결과:
┌─────────┬─────────┐
│  이름   │  나이   │
├─────────┼─────────┤
│ 홍길동  │  100    │
│ 임꺽정  │   90    │
└─────────┴─────────┘


========== TextBox (ElementName 바인딩) ==========

<TextBox Name="tBox1" Width="150" 
         Text="{Binding ElementName=lv, Path=SelectedItem.Name, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>

ElementName=lv:
- ListView "lv" 참조
- DataContext 대신 다른 요소 참조

Path=SelectedItem.Name:
- lv.SelectedItem.Name
- ListView의 선택된 항목의 Name 속성

바인딩 체인:
lv (ListView) → SelectedItem (PersonModel) → Name (string)

Mode=TwoWay:
- UI → Model: TextBox 변경 시 Name 업데이트
- Model → UI: Name 변경 시 TextBox 업데이트

UpdateSourceTrigger=PropertyChanged:
- 타이핑할 때마다 즉시 업데이트

동작:
1. ListView에서 항목 선택
2. SelectedItem.Name이 TextBox에 표시
3. TextBox에서 텍스트 수정
4. 즉시 PersonModel.Name 업데이트
5. INotifyPropertyChanged로 UI 동기화


========== Button (Command 바인딩) ==========

<Button Command="{Binding PersonCommand}"
        CommandParameter="{Binding ElementName=tBox1, Path=Text}">
    버튼
</Button>

Command="{Binding PersonCommand}":
- PersonViewModel.PersonCommand 바인딩
- ICommand 인터페이스

CommandParameter="{Binding ElementName=tBox1, Path=Text}":
- tBox1.Text를 Command에 전달
- Execute 메서드의 parameter

버튼 클릭 시 흐름:
1. CanExecute(tBox1.Text) 호출
2. CheckMessage(tBox1.Text) 실행 → true
3. 사용자가 버튼 클릭
4. Execute(tBox1.Text) 호출
5. Message(tBox1.Text) 실행
6. MessageBox.Show(tBox1.Text)

버튼 상태 자동 관리:
- tBox1.Text 변경 시
- CanExecute 재평가
- 버튼 활성화/비활성화 자동 전환


========== 바인딩 모드 비교 ==========

OneWay (Model → UI):
<TextBlock Text="{Binding Name, Mode=OneWay}"/>
- 읽기 전용

TwoWay (UI ↔ Model):
<TextBox Text="{Binding Name, Mode=TwoWay}"/>
- 양방향 동기화

OneTime:
<TextBlock Text="{Binding Name, Mode=OneTime}"/>
- 초기 한 번만


========== UpdateSourceTrigger 옵션 ==========

Default:
- TextBox: LostFocus (포커스 잃을 때)

PropertyChanged:
- 즉시 업데이트 (타이핑할 때마다)

LostFocus:
- 포커스 잃을 때

Explicit:
- 수동 UpdateSource() 호출


========== Command vs Event 비교 ==========

이벤트 핸들러 (전통적):
<Button Click="Button_Click">버튼</Button>

private void Button_Click(object sender, RoutedEventArgs e)
{
    MessageBox.Show(tBox1.Text);
}

단점:
- View와 로직 결합
- 테스트 어려움

Command (MVVM):
<Button Command="{Binding ClickCommand}">버튼</Button>

장점:
- View와 로직 분리
- 테스트 용이
- CanExecute로 상태 제어


========== MVVM 데이터 흐름 ==========

초기화:
PersonView.xaml.cs: DataContext = new PersonViewModel()
  ↓
ViewModel: PersonList 초기화, PersonCommand 생성
  ↓
XAML: 바인딩 설정 (ItemsSource, Command)
  ↓
ListView: 데이터 표시

사용자 인터랙션:
ListView 선택 → SelectedItem → TextBox 표시
  ↓
TextBox 수정 → PropertyChanged → Model 업데이트 → ListView 자동 갱신
  ↓
버튼 클릭 → CanExecute → Execute → MessageBox
